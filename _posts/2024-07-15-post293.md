---
toc: true
title:  "[Spring] H2, Mockito 안쓰고 테스트 하기 (3) - Spring Data JPA"
last_modified_at:   2024-07-15
categories : Study
excerpt: "정합성이 깨지지 않는 테스트용 JpaRepository 구현하기"
image: ""
sitemap :
  changefreq : weekly
  priority : 1.0
use_math: true
published: true
---

[2편](https://yooniversal.github.io/study/post292/)에서는 JpaRepository를 구현한 테스트용 Repository를 소개했다.<br>
그치만 TestRepository별로 엔티티 1개의 DB만 지원한다.<br>

때문에 join 쿼리가 있는 Repository라면 필요한 엔티티들에 대한 TestRepository를 필드로 선언해야만 했다.<br>

## 정합성이 깨지는 문제
그치만 해당 방식은 같은 엔티티 대상의 Repository임에도 정합성이 깨지는 문제가 발생한다.<br>
이해를 돕기위해 그림과 함께 자세히 설명해보면,<br>

아래는 운영환경에서 여러 Repository가 같은 DB에 접근하는 모습이다.<br>
실제로 DB 안에는 여러 테이블로 구성돼있기 때문에, 각 Repository는 필요한 테이블에 접근해서 데이터를 가져오게 된다.<br>
<div style="text-align: center;">
<img src="https://lh3.google.com/u/0/d/1ep4-xYEc1uXVF3HagG4V0aa_iTBAsIGL" width="60%" height="60%" title="$0715_real_status.png" alt="?"/>
</div>
<br>

그런데 TestRepository는 다르다. 다른 엔티티들에도 접근이 필요해 여러 TestRepository를 필드로 선언했지만 <br>
모두 각자 엔티티에만 접근할 수 있는 DB를 품고 있는 모습이다. 여기까지는 설명했던 내용이다.<br>
<div style="text-align: center;">
<img src="https://lh3.google.com/u/0/d/1QXb2Mnew5VYI1d7s0xKXvOt6_u8awCoK" width="45%" height="45%" title="$0715_sub_repository.png" alt="?"/>
</div>
<br>

Repository가 `ARepository`, `BRepository`를 필드로 갖고 있고, `ARepository`가 단독으로 쓰이는 경우도 있다고 해보자.<br>
(모두 다 TestJpaRepository를 상속받은 테스트용 repository라 가정한다.)<br>

Parent에 속하는 A의 value를 1 증가시켜서, ARepository에서 꺼낸 A의 value와 같은지 확인하는 테스트다.<br>
```kotlin
class DatabaseTest {
    private val repository = Repository<Parent, Long>()
    private val aRepository = ARepository<A, Long>()

    @Test
    fun `다른 Repository라면 데이터 정합성이 깨진다`() {
        // given
        val aEntity = aRepository.save(A(value = 1))
        val bEntity = B()
        val parentEntity = Parent(a = aEntity, b = bEntity)
        repository.save(parentEntity)
        
        // when
        val parent = repository.findById(1L)
        parent.a.value = parent.a.value + 1 // Parent의 A.value를 1 증가
        repository.save(parent) // 기존 A 엔티티에 대해 업데이트

        // then
        val target = repository.findById(1L).a
        val savedAEntity = aRepository.findById(1L)
        assertThat(target.value).isNotEqualTo(savedAEntity.value) // true
    }
}
```
- `target.value`와 `savedAEntity.value`는 **값이 일치하지 않아 테스트에 성공**
  + `target.value` : **2**
  + `savedAEntity.value` : 1
<br>

왜 이런 현상이 발생할까?<br>
Repository에서 필드로 갖는 ARepository를 **새 인스턴스**로 초기화해주기 때문이다.<br>
```kotlin
class TestBeverageRepository : JpaRepository<Beverage, Long> {
    private val aRepository: TestARepository<A, Long>()
}
```
<br>

그래서 같은 DB라고 생각했지만 **서로 다른 인스턴스에서 생성된 DB**(entityList)여서 정합성이 깨지는 것이다.<br>
<div style="text-align: center;">
<img src="https://lh3.google.com/u/0/d/14DLMltrJ_JD1A1mjgId6HYt0rUlQYL__" width="60%" height="60%" title="$0715_different_db.png" alt="?"/>
</div>
<br>

## 개선된 TestJpaRepository
그러면 이 경우는 어떻게 극복해야 할까?<br>
TestRepository에서 사용할 DB를 **한번에 생성해 관리하면 된다!**<br>

TestJpaRepository에서 사용하던 필드 정보들을 **TestDatabase** 클래스에서 관리한다.<br>
그리고 엔티티별로 선언해주자.<br>
```kotlin
class TestDatabase<T, ID>(
    val idName: String,
) {
    val index = AtomicLong(0L)
    val indexSet = mutableSetOf<ID>()
    val entityList = mutableListOf<T>()
}

// 엔티티별로 DB 선언
val PARENT_TEST_DB = TestDatabase<Parent, Long>("id")
val A_TEST_DB = TestDatabase<A, Long>("id")
val B_TEST_DB = TestDatabase<B, Long>("id")
```
<br>

TestJpaRepository는 TestDatabase를 생성자 파라미터로 받고, 기존 로직에서 그대로 사용할 수 있게끔 초기화해준다.<br>
```kotlin
abstract class TestJpaRepository<T, ID>(
    private val testDatabase: TestDatabase<T, ID>,
) : JpaRepository<T, ID> where T : Any {

    private val index: AtomicLong = testDatabase.index
    private val indexSet = testDatabase.indexSet
    private val idName = testDatabase.idName
    protected val entityList: MutableList<T> = testDatabase.entityList

    // 아래 로직 변경없음
}
```
<br>

TestRepository를 정의할 때는 TestDatabase를 생성자에서 받으면 된다.<br>
연관된 Repository도 초기화해주는 점 잊지 말자!<br>
```kotlin
class TestParentRepository : TestJpaRepository<Parent, Long>(PARENT_TEST_DB) {
    private val aRepository: TestARepository()
    private val bRepository: TestBRepository()
}

class TestARepository : TestJpaRepository<A, Long>(A_TEST_DB)
class TestBRepository : TestJpaRepository<B, Long>(B_TEST_DB)
```
<br>

그러면 다른 위치에 있는 Repository여도 같은 TestDatabase로 초기화하기 때문에 <br>
더 이상 데이터 정합성이 깨지는 현상이 발생하지 않는다!<br>
<div style="text-align: center;">
<img src="https://lh3.google.com/u/0/d/1XMWdwh7HBeNSWTmvjtb1Z6mLP_ZuXyLY" width="55%" height="55%" title="$0715_initilaized_db.png" alt="?"/>
</div>

DB를 일치시켜주는 것 외에도 JpaRepository에서 제공하는 함수도 같이 수정해줘야한다.<br>
```kotlin
fun save(parent: Parent): Parent {
    return super.save(parent).also { parent -> 
        aRepository.save(parent.a)
        bRepository.save(parent.b)
    }
}

fun findById(id: Long): Parent {
    return super.findById(id).let { parent ->
        parent.a = aRepository.findById(parent.a.id)
        parent.b = bRepository.findById(parent.b.id)
    }
}
...
```
<br>

### 단점
[2편](https://yooniversal.github.io/study/post292/)의 TestJpaRepository보다 정합성을 깨뜨리지 않기위해 추가해줘야 하는 코드가 늘었다.<br>
운영 환경에서는 사용하는 엔티티가 많을 텐데, 이에 비례해서 추가할 TestDatabase 인스턴스도 많아질 것이다.<br>
일부 TestRepository에서는 JpaRepository에서 제공하는 함수도 사실상 재구현을 해야하기 때문에 부담이 크다.<br>

테스트에서 정합성이 깨질 수 있는 상황이거나 그렇게 될 수 있다면 적용할 필요가 있겠지만, <br>
그렇지 않다면 2편의 TestJpaRepository를 쓰는게 좋을 것 같다.<br>

대부분 테스트가 단위 테스트일거 같은데, 그런 경우에는 사실 필요없을 것 같다🤔<br>

## References
- [Java/Spring 테스트를 추가하고 싶은 개발자들의 오답노트](https://www.inflearn.com/course/자바-스프링-테스트-개발자-오답노트)