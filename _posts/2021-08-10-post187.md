---
toc: true
title:  "자바 ORM 표준 JPA 프로그래밍 - 1장, JPA 소개"
last_modified_at:   2021-08-10
categories : Study
excerpt: ""
image: "https://drive.google.com/uc?id=1TrLyyAj3GYwbHIhkA2g_-KGeZUoHYWGL"
sitemap :
  changefreq : weekly
  priority : 1.0
use_math: true
---

**자바 ORM 표준 JPA 프로그래밍**에서 읽은 내용을 정리하는 글입니다😄<br>

### 1.1 SQL을 직접 다룰 때 발생하는 문제점
관계형 데이터베이스를 신뢰할 수 있고 안전하다는 장점때문에 데이터 저장소로 활용한다.<br>
하지만 간단한 기능인 CRUD 기능을 개발하는데도 **비슷**하거나 **반복적인 코드**를 작성해야한다.<br>
자바 컬렉션에 저장하듯이 수정한다면 코드량은 크게 줄겠지만 데이터베이스와 구조가 달라서<br>
개발자는 객체지향 애플리케이션과 데이터베이스 중간에서 많은 양의 SQL과 JDBC API를 활용해<br>
지루하고 반복적인 작업을 유지보수가 필요할 때마다 해줘야하는 문제점이 발생한다.<br>

Member 객체 안에 Team 객체라는 정보가 있다고 하자. (연관된 객체)<br>
그러면 연관된 Team 객체 사용 여부는 사용하는 SQL에 의존적일 수밖에 없다.<br>
이런 상황에서는 개발자가 **엔티티**(비즈니스 요구 사항을 모델링한 객체)**를 신뢰할 수 없게 된다**.<br>
그러므로 회원 객체를 관리하는 MemberDAO를 열고 실행되는 SQL과 조회되는 객체를 일일이 확인해야한다.<br>
계층은 분할했지만 엔티티와 강한 의존 관계때문에 **진정한 의미의 계층 분할이 됐다고 보기 어렵다**.<br>
결과적으로 필드 하나를 추가만 해도 CRUD, SQL 코드 대부분을 수정하는 문제가 발생하게 되고<br>
**SQL에 의존적인 개발을 피하기 어렵게 된다**.

- 개발할 때마다 비슷하고 반복적인 코드를 작성하는 번거로움
- 엔티티를 신뢰할 수 없음
- 진정한 의미의 계층 분할이 이뤄지지 않음
- SQL에 의존적인 개발을 피하기 어려움

JPA는 이 문제들을 해결해준다.<br>
개발자는 JPA가 제공하는 API를 활용하고, JPA는 적절한 SQL을 생성해 데이터베이스에 전달한다.<br>
가령, [여기](https://yooniversal.github.io/blog/post185/)에서 `스프링 JdbcTemplate`의 `save()`가 회원 객체 저장에 필요한 코드라면<br>
JPA가 제공하는 CRUD API를 활용한 저장 방법은 다음과 같다.<br>
```java
jpa.persist(member);
```

연관된 객체를 사용하는 시점에는 적절한 SELECT SQL을 실행함으로써 문제를 해결한다.<br>
즉, JPA를 사용하면서 연관된 객체를 마음껏 조회할 수 있게 된다!<br>

### 1.2 패러다임의 불일치
객체지향 프로그래밍은 *추상화, 캡슐화, 정보은닉, 상속, 다형성* 등의 장치들이 있다.<br>
하지만 데이터베이스는 데이터 중심으로 구조화 돼있고 **위와 같은 개념이 존재하지 않는다**.<br>
이러한 패러다임의 불일치 문제를 개발자가 중재하면서 많은 시간과 코드를 소비하게 된다😓<br>
지금까지는 열심히 코드를 작성하면 어느정도 극복할 수 있겠지만 그렇지 않은 유형도 존재한다.<br>

<blockquote>
객체 그래프 탐색
</blockquote>

`1.1`에서 언급한 것처럼 Member 안에 Team이라는 연관된 객체의 정보가 있다고 하자.<br>
그리고 추가로 Team과 연관된 객체가 존재하고 그 객체에도 연관된 객체가 존재한다고 해보자.<br>
객체는 다음과 같이 탐색이 자유롭게 가능하다.<br>
```java
member.getTeam().getInfo1().getInfo2() ...
```

하지만 SQL은 처음 실행하는 SQL에 따라 **객체 그래프를 어디까지 탐색할지 정해진다**.<br>
상황에 따라 탐색 범위는 달라질 수 있는 상황에서 이런 제약은 큰 문제로 남는다.<br>
어쩔 수 없이 적절한 탐색 범위 설정을 위해 DAO에서 SQL을 직접 확인해야 하는데<br>
결국 엔티티가 SQL에 의존적이어서 발생하는 문제이다.<br>

JPA는 객체 사용 시점에 적절한 SELECT SQL을 실행하기 때문에 마음껏 조회할 수 있다.<br>
실제 객체를 사용하는 시점까지 데이터베이스 조회를 미루는 **지연 로딩**이라는 방법을 통해서 해결한다.<br>
필요에 따라 연관된 객체를 함께 조회할지 말지 간단한 설정으로 정의가 가능하다.<br>

<blockquote>
비교
</blockquote>
데이터베이스는 **기본 키**의 값으로 각 row를 구분한다.<br>
하지만 객체의 비교 방식은 동일성 비교(==), 동등성 비교(*equals()*)가 있다.<br>
즉, 테이블 로우 구분 방법과 객체를 구분하는 방법에는 **차이**가 있다.<br>
(동일성 비교에서 만약 객체를 컬렉션에 보관했다면 true를 그렇지 않다면 false를 리턴한다)<br>

결국 패러다임의 불일치로 인한 문제가 원인인데, **JPA는 같은 객체가 조회될 수 있도록 보장한다**.<br>

### 1.3 JPA란 무엇인가?
JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준으로, 자바 애플리케이션과 JDBC 사이에서 동작한다.<br>
ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑하는 것을 의미한다.<br>
ORM 프레임워크는 매핑을 통해 패러다임 불일치 문제를 개발자 대신 해결한다.<br>
(앞서 JPA 사용시 얻게되는 이점들을 참고)<br>
그렇기 때문에 개발자는 **객체지향 애플리케이션 개발에 집중**할 수 있게 된다.<br>

추가로 위 내용에 이어서 JPA의 특징은 다음과 같다.
* 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공
* 데이터 접근 추상화와 벤더 독립성 : 특정 데이터베이스 기술에 종속되지 않음
* 표준 : 자바 진영의 ORM 기술 표준이므로 다른 구현 기술로의 변경이 쉬움

<script src="https://utteranc.es/client.js"
        repo="yooniversal/blog-comments"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
